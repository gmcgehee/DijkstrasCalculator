namespace Stacking
{       
    public class MyStack<T> : IEnumerable<T>
    {  
        private T[] a;
        private int Count = -1;
        private int capacity;

        /// <summary>
        /// Initializes the stack
        /// </summary>
        /// <param name="capacity"></param>
        public MyStack(int capacity = 64)
        {
            this.capacity = capacity;
            a = new T[capacity];
        }

        /// <summary>
        /// Checks if the stack is empty
        /// </summary>
        /// <returns>bool</returns>
        public bool IsEmpty()
        {
            if (Count == -1)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Adds an item to top of the stack
        /// </summary>
        /// <param name="item">String to be added</param>
        public void Push(T item)
        {
            if (Count < a.Length - 1)
            { 
                a[++Count] = item;
            }
            else
            {
                T[] b = new T[a.Length * 2];
                capacity *= 2;
                for (int i = 0; i < a.Length; i++)
                {
                    b[i] = a[i];
                }

                a = new T[capacity];

                for (int i = 0; i < b.Length; i++)
                {
                    a[i] = b[i];
                }


                Console.WriteLine("Pushed " + item);
                a[++Count] = item;

            }
        }

        /// <summary>
        /// Removes the top item from the stack and returns it
        /// </summary>
        /// <returns>Top value of stack</returns>
        public T Pop()
        {
            if (Count !< a.Length - 1)
            {
                T save = a[Count];
                a[Count] = default;
                Count--;
                return save;
            } else
            {
                T[] b = new T[a.Length / 2];
                capacity /= 2;

                for (int i = 0; i < a.Length; i++)
                {
                    b[i] = a[i];
                }

                a = new T[capacity];

                for (int i = 0; i < b.Length; i++)
                {
                    a[i] = b[i];
                }

                T save = a[Count];
                a[Count] = default;
                Count--;
                return save;

            }
        }

        /// <summary>
        /// Shows the value at the top of the stack without popping it off
        /// </summary>
        /// <returns>Value at top of stack</returns>
        /// <exception cref="InvalidOperationException"></exception>
        public T Peek()
        {
            if (Count >= 0)
            {
                return a[Count];
            }
            else
            {
                throw new InvalidOperationException("Stack is empty!");
            }
        }

        // ToString function generated by GPT 3.5 8/31/2023
        // 
        /// <summary>
        /// Returns the stack type, name, and percentage full.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            int count = Count + 1;
            int remainingCapacity = capacity - count;

            if (count == 0)
            {
                return $"{typeof(MyStack<T>).Name} is empty";
            }
            else
            {
                List<string> displayedValues = new List<string>();

                for (int i = 0; i < count; i++)
                {
                    displayedValues.Add(a[i].ToString());
                }

                string valuesToDisplay = "";

                if (count <= 6)
                {
                    valuesToDisplay = string.Join(", ", displayedValues);
                }
                else
                {
                    string firstValues = string.Join(", ", displayedValues.GetRange(0, 3));
                    string lastValues = string.Join(", ", displayedValues.GetRange(count - 3, 3));
                    valuesToDisplay = $"{firstValues}... {lastValues}";
                }

                return $"{typeof(MyStack<T>).Name} is {count}/{capacity} full: {valuesToDisplay}.";
            }
        }
        /// <summary>
        /// Integrates IEnumerator functionality
        /// </summary>
        /// <returns>Enumerator function</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        /// <summary>
        /// Integrates IEnumerator functionality
        /// </summary>
        /// <returns>The current reference in the array</returns>
        public IEnumerator<T> GetEnumerator()
        {
            for (int i = Count; i >= 0; i--)
            {
                yield return a[i];
            }
        }

    }
}
