using System;

namespace QueueLib;
public class MyQueue<T> : IEnumerable<T> {
    class MyNode<T> {

        public T data;
        public MyNode<T> next;

        public MyNode(T value = default) {
            data = value;
            next = null;
        }
    }

    private MyNode<T> head;
    private MyNode<T> tail;

    private int count = 0;
    public MyQueue() {

        head = null;

    }

    /// <summary>
    /// Adds a new node to the back of the queue
    /// </summary>
    /// <param name="item"></param>
    public void Enqueue(T item) {

        MyNode<T> node = new MyNode<T>(item);
        
        if (count > 0) {

            tail.next = node;

            tail = node;

        } else {

            head = node;

            tail = head;      

        }
        count++;
    }
    
    /// <summary>
    /// Converts the queue to an array
    /// </summary>
    /// <returns>Queue as an array</returns>
    public T[] ToArray() {
        MyNode<T> curr = head;
        T[] arr = new T[count];
        int i = 0;
        while (curr != null) {
            arr[i] = curr.data; 
            i++;
            curr = curr.next;
        }
        return arr;
    }
    
    /// <summary>
    /// Creates a queue based off of an array
    /// </summary>
    /// <param name="arr"></param>

    public MyQueue(T[] arr) {
        for (int i = 0; i < arr.Length; i++) {
            this.Enqueue(arr[i]);
        }
    }
    /// <summary>
    /// Dequeues the head from the queue
    /// </summary>
    /// <returns>Returns the data of the head node</returns>
    /// <exception cref="InvalidOperationException"></exception>
    public T Dequeue() {
        if (count == 0) {
            throw new InvalidOperationException("Queue is empty");
        }
        if (count == 1) {
            MyNode<T> saved = head;
            head = tail = null;
            count = 0;
            return saved.data;
        } else { // Do this
            MyNode<T> saved = head;
            head = head.next;
            count--;
            return saved.data;
        }
    }

    /// <summary>
    /// Checks if there are any nodes
    /// </summary>
    /// <returns>If there are any nodes</returns>
    public bool IsEmpty() {

        if (count != 0) return false;

        else return true;

    }

    /// <summary>
    /// Clears the queue.
    /// </summary>
    /// ChatGPT 9/5/2023
    public void Clear() {
        head = null;
        tail = null;
        count = 0;
    }


    /// <summary>
    /// Outputs a reasonable format of the stack
    /// </summary>
    /// <returns>Reasonable formatting of stack</returns>
    /// ToString function writted by ChatGPT 9/5/2023
    // ToString override for MyQueue
    public override string ToString() {
        if (count == 0) {
            return $"{typeof(MyQueue<T>).Name} is empty";
        }
        else {
            List<string> displayedValues = new List<string>();
            MyNode<T> curr = head;

            while (curr != null) {
                displayedValues.Add($"\"{curr.data.ToString()}\"");
                curr = curr.next;
            }

            string valuesToDisplay;

            if (count <= 6) {
                valuesToDisplay = string.Join(", ", displayedValues);
            }
            else {
                List<string> firstThree = new List<string>();
                List<string> lastThree = new List<string>();
                int index = 0;
                curr = head;

                while (index < 3 && curr != null) {
                    firstThree.Add($"\"{curr.data.ToString()}\"");
                    index++;
                    curr = curr.next;
                }

                curr = head;
                int lastIndex = count - 3;
                index = 0;

                while ((index < lastIndex) && (curr != null)) {
                    index++;
                    curr = curr.next;
                }

                while (curr != null) {
                    lastThree.Add($"\"{curr.data.ToString()}\"");
                    curr = curr.next;
                }

                valuesToDisplay = $"{string.Join(", ", firstThree)}... {string.Join(", ", lastThree)}";
            }

            return $"{typeof(MyQueue<T>).Name} has {count} elements: {valuesToDisplay}";
        }
    }

    /// <summary>
    /// Peeks at the element at the front of the queue without removing it.
    /// </summary>
    /// <returns>The element at the front of the queue.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the queue is empty.</exception>
    /// Peek function generated by ChatGPT 9/7/23 
    /// This is what it wrote!
    public T Peek() {
        if (count == 0) {
            throw new InvalidOperationException("Queue is empty");
        }
        return head.data;
    }



    /// <summary>
    /// Integrates IEnumerator functionality
    /// </summary>
    /// <returns>Enumerator function</returns>
    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        return this.GetEnumerator();
    }

    /// <summary>
    /// Integrates IEnumerator functionality
    /// </summary>
    /// <returns>The current reference in the array</returns>
    public IEnumerator<T> GetEnumerator() {
        MyNode<T> curr = head;
        while (curr != null) {
            yield return curr.data; 
            curr = curr.next;
        }
    }
    
}
